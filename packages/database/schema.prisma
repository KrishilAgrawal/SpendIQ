generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// AUTHENTICATION & ACCESS CONTROL
// ============================================================================

model User {
  id        String   @id @default(uuid())
  loginId   String   @unique
  email     String   @unique
  password  String
  name      String?
  role      Role     @default(PORTAL_USER)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  sessions       Session[]
  auditLogs      AuditLog[]
  createdBudgets Budget[]   @relation("BudgetCreator")
  contact        Contact?   @relation("PortalUser")
  
  @@map("users")
}

// Role enum moved to bottom or redefined


model Session {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
  
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

// ============================================================================
// MASTER DATA
// ============================================================================

model Contact {
  id        String      @id @default(uuid())
  name      String
  email     String      @unique
  phone     String?
  
  // Address fields
  street    String?
  city      String?
  state     String?
  country   String?
  pincode   String?
  
  type      ContactType
  status    Status      @default(ACTIVE)
  imageUrl  String?
  
  portalUserId String?    @unique
  portalUser   User?      @relation("PortalUser", fields: [portalUserId], references: [id])
  isPortalUser Boolean    @default(false)
  
  tags      ContactTag[]
  
  salesOrders     SalesOrder[]
  purchaseOrders  PurchaseOrder[]
  invoices        Invoice[]
  payments        Payment[]
  journalEntries  JournalEntryLine[]
  
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt

  @@map("contacts")
}

enum ContactType {
  CUSTOMER
  VENDOR
}

enum Status {
  ACTIVE
  ARCHIVED
}

enum Role {
  ADMIN
  PORTAL_USER
}


model Product {
  id          String   @id @default(uuid())
  name        String
  description String?
  
  salesPrice    Decimal  @default(0.00) @db.Decimal(10, 2)
  purchasePrice Decimal  @default(0.00) @db.Decimal(10, 2)
  
  status      Status   @default(ACTIVE)
  
  categoryId  String?
  category    ProductCategory? @relation(fields: [categoryId], references: [id])
  
  defaultAnalyticAccountId String?
  defaultAnalyticAccount   AnalyticalAccount? @relation("DefaultAnalytic", fields: [defaultAnalyticAccountId], references: [id])

  invoiceLines InvoiceLine[]
  poLines      PurchaseOrderLine[]
  soLines      SalesOrderLine[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("products")
}


// Tag system for contacts
model Tag {
  id        String       @id @default(uuid())
  name      String       @unique
  color     String?
  contacts  ContactTag[]
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt
  
  @@map("tags")
}

model ContactTag {
  contactId String
  tagId     String
  contact   Contact @relation(fields: [contactId], references: [id], onDelete: Cascade)
  tag       Tag     @relation(fields: [tagId], references: [id], onDelete: Cascade)
  
  @@id([contactId, tagId])
  @@map("contact_tags")
}

model ProductCategory {
  id          String   @id @default(uuid())
  name        String
  parentId    String?
  parent      ProductCategory?  @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children    ProductCategory[] @relation("CategoryHierarchy")
  products    Product[]

  @@map("product_categories")
}

model AnalyticalAccount {
  id          String   @id @default(uuid())
  code        String   @unique
  name        String
  parentId    String?
  parent      AnalyticalAccount?  @relation("AnalyticHierarchy", fields: [parentId], references: [id])
  children    AnalyticalAccount[] @relation("AnalyticHierarchy")
  
  entries     JournalEntryLine[]
  invoiceLines InvoiceLine[]
  budgets     Budget[]
  defaultForProducts Product[] @relation("DefaultAnalytic")
  poLines     PurchaseOrderLine[] @relation("POLineAnalytic")
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([code])
  @@map("analytical_accounts")
}

// General Ledger Account (Required for Double Entry)
model Account {
  id          String   @id @default(uuid())
  code        String   @unique
  name        String
  type        AccountType
  reconcilable Boolean    @default(false)
  
  entries     JournalEntryLine[]

  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  @@map("accounts")
}

enum AccountType {
  ASSET
  LIABILITY
  EQUITY
  INCOME
  EXPENSE
}

// ============================================================================
// BUDGETING
// ============================================================================

model Budget {
  id                    String              @id @default(uuid())
  name                  String
  
  // Period-based instead of fiscal year
  startDate             DateTime
  endDate               DateTime
  
  // Required link to analytic account (cost center)
  analyticAccountId     String
  analyticAccount       AnalyticalAccount   @relation(fields: [analyticAccountId], references: [id])
  
  // Budget type for categorization
  budgetType            BudgetType
  
  // Single budgeted amount (no budget lines)
  budgetedAmount        Decimal             @db.Decimal(15, 2)
  
  // Status workflow
  status                BudgetStatus        @default(DRAFT)
  
  // Revision chain (simplified)
  revisionOfId          String?             @unique
  revisionOf            Budget?             @relation("BudgetRevision", fields: [revisionOfId], references: [id])
  revisedBy             Budget?             @relation("BudgetRevision")
  
  // Audit fields
  createdBy             String
  creator               User                @relation("BudgetCreator", fields: [createdBy], references: [id])
  
  createdAt             DateTime            @default(now())
  updatedAt             DateTime            @updatedAt
  
  @@index([analyticAccountId])
  @@index([startDate, endDate])
  @@index([status])
  @@map("budgets")
}

enum BudgetType {
  INCOME
  EXPENSE
}

enum BudgetStatus {
  DRAFT      // Editable, no actuals
  CONFIRMED  // Locked, actuals computing
  REVISED    // Old version, read-only
  ARCHIVED   // Hidden from default list
}

// ============================================================================
// TRANSACTIONS (PO, SO, INVOICE)
// ============================================================================

model PurchaseOrder {
  id          String   @id @default(uuid())
  poNumber    String   @unique // PO-000001
  vendorId    String
  vendor      Contact  @relation(fields: [vendorId], references: [id])
  
  orderDate   DateTime
  status      PurchOrderStatus @default(DRAFT)
  
  subtotal    Decimal  @db.Decimal(15, 2)
  taxAmount   Decimal  @default(0) @db.Decimal(15, 2)
  totalAmount Decimal  @db.Decimal(15, 2)
  
  lines       PurchaseOrderLine[]
  invoices    Invoice[] // Linked bills

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("purchase_orders")
}

model PurchaseOrderLine {
  id          String   @id @default(uuid())
  purchaseOrderId String
  purchaseOrder   PurchaseOrder @relation(fields: [purchaseOrderId], references: [id], onDelete: Cascade)
  
  productId   String
  product     Product  @relation(fields: [productId], references: [id])
  
  description String
  quantity    Decimal  @db.Decimal(10, 2)
  unitPrice   Decimal  @db.Decimal(10, 2)
  subtotal    Decimal  @db.Decimal(15, 2)
  
  analyticalAccountId String?
  analyticalAccount   AnalyticalAccount? @relation("POLineAnalytic", fields: [analyticalAccountId], references: [id])

  @@map("purchase_order_lines")
}

enum PurchOrderStatus {
  DRAFT
  CONFIRMED
  CANCELLED
}

model SalesOrder {
  id          String   @id @default(uuid())
  reference   String   @unique // SO-2023-001
  customerId  String
  customer    Contact  @relation(fields: [customerId], references: [id])
  
  date        DateTime
  status      SalesOrderStatus @default(DRAFT)
  
  totalAmount Decimal  @db.Decimal(15, 2)
  
  lines       SalesOrderLine[]
  invoices    Invoice[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("sales_orders")
}

model SalesOrderLine {
  id          String   @id @default(uuid())
  orderId     String
  order       SalesOrder @relation(fields: [orderId], references: [id], onDelete: Cascade)
  
  productId   String
  product     Product  @relation(fields: [productId], references: [id])
  
  quantity    Decimal  @db.Decimal(10, 2)
  unitPrice   Decimal  @db.Decimal(10, 2)
  subtotal    Decimal  @db.Decimal(15, 2)

  @@map("sales_order_lines")
}

enum SalesOrderStatus {
  DRAFT
  SENT
  CONFIRMED
  DELIVERED
  INVOICED
  CANCELLED
}

model Invoice {
  id          String   @id @default(uuid())
  number      String   @unique // INV-2023-001
  type        InvoiceType // IN_INVOICE (Vendor Bill), OUT_INVOICE (Customer Invoice)
  
  partnerId   String
  partner     Contact  @relation(fields: [partnerId], references: [id])
  
  date        DateTime
  dueDate     DateTime
  
  status      InvoiceStatus @default(DRAFT)
  paymentState PaymentState @default(NOT_PAID)
  
  totalAmount Decimal  @db.Decimal(15, 2)
  taxAmount   Decimal  @default(0) @db.Decimal(15, 2)
  
  lines       InvoiceLine[]
  payments    PaymentAllocation[]
  
  // Links
  salesOrderId    String?
  salesOrder      SalesOrder? @relation(fields: [salesOrderId], references: [id])
  purchaseOrderId String?
  purchaseOrder   PurchaseOrder? @relation(fields: [purchaseOrderId], references: [id])
  
  // Accounting Link
  journalEntryId  String? @unique
  journalEntry    JournalEntry? @relation(fields: [journalEntryId], references: [id])

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([date])
  @@index([partnerId])
  @@map("invoices")
}

enum InvoiceType {
  OUT_INVOICE // Customer Invoice
  OUT_REFUND  // Customer Credit Note
  IN_INVOICE  // Vendor Bill
  IN_REFUND   // Vendor Credit Note
}

enum InvoiceStatus {
  DRAFT
  POSTED
  CANCELLED
}

enum PaymentState {
  NOT_PAID
  PARTIAL
  PAID
}

model InvoiceLine {
  id            String   @id @default(uuid())
  invoiceId     String
  invoice       Invoice  @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  
  productId     String?
  product       Product? @relation(fields: [productId], references: [id])
  label         String
  
  quantity      Decimal  @default(1) @db.Decimal(10, 2)
  priceUnit     Decimal  @db.Decimal(10, 2)
  taxRate       Decimal  @default(0) @db.Decimal(5, 2)
  subtotal      Decimal  @db.Decimal(15, 2)
  
  // This line links to an Analytic Account for budget tracking
  analyticAccountId String?
  analyticAccount   AnalyticalAccount? @relation(fields: [analyticAccountId], references: [id])

  @@map("invoice_lines")
}

// ============================================================================
// PAYMENTS & RECONCILIATION
// ============================================================================

model Payment {
  id          String   @id @default(uuid())
  reference   String   @unique
  partnerId   String
  partner     Contact  @relation(fields: [partnerId], references: [id])
  
  date        DateTime
  amount      Decimal  @db.Decimal(15, 2)
  type        PaymentType
  
  method      String   // BANK, CASH
  status      PaymentStatus @default(DRAFT)
  
  allocations PaymentAllocation[]
  
  // Accounting Link
  journalEntryId  String? @unique
  journalEntry    JournalEntry? @relation(fields: [journalEntryId], references: [id])

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("payments")
}

enum PaymentType {
  INBOUND  // Customer paying us
  OUTBOUND // Us paying vendor
}

enum PaymentStatus {
  DRAFT
  POSTED
  CANCELLED
}

model PaymentAllocation {
  id          String   @id @default(uuid())
  paymentId   String
  payment     Payment  @relation(fields: [paymentId], references: [id])
  
  invoiceId   String
  invoice     Invoice  @relation(fields: [invoiceId], references: [id])
  
  amount      Decimal  @db.Decimal(15, 2)
  
  createdAt   DateTime @default(now())

  @@map("payment_allocations")
}

// ============================================================================
// ACCOUNTING CORE
// ============================================================================

model JournalEntry {
  id          String   @id @default(uuid())
  number      String?  @unique
  date        DateTime
  reference   String?
  journalId   String?  // Could be 'Sales', 'Purchase', 'Bank'
  
  state       EntryState @default(DRAFT)
  
  lines       JournalEntryLine[]
  
  // Reverse relations are handled in Invoice/Payment models
  invoice     Invoice?
  payment     Payment?

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([date])
  @@map("journal_entries")
}

enum EntryState {
  DRAFT
  POSTED
  CANCELLED
}

model JournalEntryLine {
  id             String   @id @default(uuid())
  entryId        String
  entry          JournalEntry @relation(fields: [entryId], references: [id], onDelete: Cascade)
  
  accountId      String
  account        Account      @relation(fields: [accountId], references: [id])
  
  partnerId      String?
  partner        Contact?     @relation(fields: [partnerId], references: [id])
  
  label          String?
  
  debit          Decimal  @default(0) @db.Decimal(15, 2)
  credit         Decimal  @default(0) @db.Decimal(15, 2)
  
  // Analytic distribution
  analyticAccountId String?
  analyticAccount   AnalyticalAccount? @relation(fields: [analyticAccountId], references: [id])
  
  reconciled     Boolean  @default(false)

  createdAt      DateTime @default(now())

  @@index([accountId])
  @@index([analyticAccountId])
  @@map("journal_entry_lines")
}

// ============================================================================
// AUTOMATION & AUDIT
// ============================================================================

model AutoAnalyticalRule {
  id          String   @id @default(uuid())
  name        String
  priority    Int      @default(0)
  
  // The target analytic account to apply
  targetAccountId String
  
  conditions  RuleCondition[]
  
  active      Boolean  @default(true)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("auto_analytical_rules")
}

model RuleCondition {
  id          String   @id @default(uuid())
  ruleId      String
  rule        AutoAnalyticalRule @relation(fields: [ruleId], references: [id], onDelete: Cascade)
  
  field       RuleField // VENDOR, PRODUCT_CATEGORY, DESCRIPTION
  operator    RuleOperator // CONTAINS, EQUALS
  value       String
  
  @@map("rule_conditions")
}

enum RuleField {
  VENDOR
  PRODUCT_CATEGORY
  DESCRIPTION
  ACCOUNT
}

enum RuleOperator {
  EQUALS
  CONTAINS
  STARTS_WITH
}







model AuditLog {
  id          String   @id @default(uuid())
  action      String   // CREATE, UPDATE, DELETE
  entity      String   // Budget, Payment...
  entityId    String
  
  userId      String?
  user        User?    @relation(fields: [userId], references: [id])
  
  details     Json?    // Before/After state
  
  createdAt   DateTime @default(now())

  @@index([entityId])
  @@map("audit_logs")
}

model OtpVerification {
  id        String   @id @default(uuid())
  email     String
  otp       String
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([email])
  @@map("otp_verifications")
}